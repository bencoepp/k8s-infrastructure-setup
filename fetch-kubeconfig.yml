---
- name: Generate user cert, bind user, and create local inline kubeconfig
  hosts: node1
  become: yes
  gather_facts: no

  vars:
    # Adjust these variables for your environment:
    kube_apiserver_lb_url: "49.12.16.161:6443"
    kube_user_name: "bcp-lb-user"
    kube_user_group: "bcp"

    # Where the certs will be generated & stored on the control-plane node
    user_cert_dir: "/etc/kubernetes/pki"

    # Local path for the final kubeconfig file (on your Ansible control machine)
    kube_config_local_path: "./{{ kube_user_name }}.kubeconfig"

  tasks:
    - name: Ensure cert directory exists
      file:
        path: "{{ user_cert_dir }}"
        state: directory
        mode: '0755'

    - name: Generate user private key
      command: >
        openssl genrsa
        -out {{ user_cert_dir }}/{{ kube_user_name }}.key
        2048
      args:
        creates: "{{ user_cert_dir }}/{{ kube_user_name }}.key"

    - name: Generate CSR for the user
      command: >
        openssl req -new
        -key {{ user_cert_dir }}/{{ kube_user_name }}.key
        -out {{ user_cert_dir }}/{{ kube_user_name }}.csr
        -subj "/CN={{ kube_user_name }}/O={{ kube_user_group }}"
      args:
        creates: "{{ user_cert_dir }}/{{ kube_user_name }}.csr"

    - name: Sign the CSR with the cluster CA
      command: >
        openssl x509
        -req
        -in {{ user_cert_dir }}/{{ kube_user_name }}.csr
        -CA {{ user_cert_dir }}/ca.crt
        -CAkey {{ user_cert_dir }}/ca.key
        -CAcreateserial
        -out {{ user_cert_dir }}/{{ kube_user_name }}.crt
        -days 365
      args:
        creates: "{{ user_cert_dir }}/{{ kube_user_name }}.crt"

    - name: Create ClusterRoleBinding for the user (with cluster-admin as example)
      # In production, replace 'cluster-admin' with a more restrictive role
      command: >
        kubectl create clusterrolebinding {{ kube_user_name }}-clusteradmin-binding
        --clusterrole=cluster-admin
        --user={{ kube_user_name }}
      register: crb_result
      failed_when: crb_result.rc not in [0, 1]
      # Allows ignoring "AlreadyExists" errors when binding already exists

    # -- Slurp the certificates/keys to embed them in the kubeconfig --

    - name: Slurp cluster CA cert
      slurp:
        src: "{{ user_cert_dir }}/ca.crt"
      register: slurped_ca

    - name: Set fact for CA cert (base64)
      set_fact:
        ca_cert_b64: "{{ slurped_ca.content }}"

    - name: Slurp user certificate
      slurp:
        src: "{{ user_cert_dir }}/{{ kube_user_name }}.crt"
      register: slurped_user_crt

    - name: Set fact for user certificate (base64)
      set_fact:
        user_cert_b64: "{{ slurped_user_crt.content }}"

    - name: Slurp user key
      slurp:
        src: "{{ user_cert_dir }}/{{ kube_user_name }}.key"
      register: slurped_user_key

    - name: Set fact for user key (base64)
      set_fact:
        user_key_b64: "{{ slurped_user_key.content }}"

    # -- Render the kubeconfig locally with inline cert data --

    - name: Render local kubeconfig with inline certificates
      template:
        src: "templates/kubeconfig.j2"
        dest: "{{ kube_config_local_path }}"
      delegate_to: localhost
      run_once: true

    - name: Show success message
      debug:
        msg: "Kubeconfig with inline certificates created: {{ kube_config_local_path }}"
